<!DOCTYPE html>

<html>
    <head>
        <meta charset="UTF-8">
        <title>Algoritmhs CookBook</title>
        <link rel="stylesheet" href="css/style.css">
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                let elements = [...document.getElementsByClassName("sorting")]
                elements.forEach((element) => {
                    element.innerHTML='<object class="full" type="text/html" data="canvas.html?Sort='+element.id+'" ></object>'
                })
            });
        </script> 
    </head>
    <body>
        <h1>Algoritmhs CookBook</h1>
        <div class="grid">
            <div class="item">
                <h2>Radix Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n+k)</h4>
                        <p>
                            Radix sort utilizza un procedimento controintuitivo per l'uomo, ma pi√π facilmente implementabile. Esegue gli ordinamenti per posizione della cifra ma partendo dalla cifra meno significativa. Questo affinch√© l'algoritmo non si trovi a dovere operare ricorsivamente su sottoproblemi di dimensione non valutabili a priori.
                        </p>
                    </div>
                    <div id="radixsort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Counting Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n)</h4>
                        <p>
                            Il Counting sort √® un algoritmo di ordinamento per valori numerici interi con complessit√† lineare. L'algoritmo si basa sulla conoscenza a priori dell'intervallo in cui sono compresi i valori da ordinare.
                            L'algoritmo conta il numero di occorrenze di ciascun valore presente nell'array da ordinare, memorizzando questa informazione in un array temporaneo di dimensione pari all'intervallo di valori. Il numero di ripetizioni dei valori inferiori indica la posizione del valore immediatamente successivo. 
                        </p>
                    </div>
                    <div id="countingsort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Merge Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† ùöØ(nlog(n))</h4>
                        <p>
                            Il Merge sort √® un algoritmo di tipo divide et impera in cui:
                            <ul>
                                <li><em>Divide</em>: l‚Äôarray A in n subarray, ognuno contente un elemento (l‚Äôarray di un elemento solo √® considerato ordinato)</li>
                                <li><em>Impera</em>: viene fatto il merge di due subarray ordinati ritornando un solo array ordinato di lunghezza A‚Äô.length + A‚Äô‚Äò.length viene ripetuto il merge fino a che non riotteniamo un solo array ordinato.</li>
                            </ul>
                        </p>
                    </div>
                    <div id="mergesort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Quick Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† nel caso pessimo O(n¬≤)</h4>
                        <p>
                            Quicksort √® un algoritmo di ordinamento ricorsivo in place non stabile. Tale procedura ricorsiva viene comunemente detta partition: preso un elemento chiamato "pivot" da una struttura dati (es. array) si pongono gli elementi minori a sinistra rispetto al pivot e gli elementi maggiori a destra. L'operazione viene quindi reiterata sui due insiemi risultanti fino al completo ordinamento della struttura.
                        </p>
                    </div>
                    <div id="quicksort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Heap Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(nlog(n))</h4>
                        <p>
                            L'heapsort, per eseguire l'ordinamento, utilizza una struttura chiamata heap; un heap √® rappresentabile con un albero binario in cui tutti i nodi seguono una data propriet√†, detta priorit√†. Esso √® completo almeno fino al penultimo livello dell'albero (con le foglie sull'ultimo livello compattate a sinistra) e ad ogni nodo corrisponde uno ed un solo elemento.

                            In uno heap decrescente (utilizzato per ordinare ad esempio un array in senso crescente) ogni nodo padre contiene un valore maggiore o uguale a quello dei suoi due figli diretti, di conseguenza risulter√† maggiore anche di tutti i nodi che si trovano nel sottoalbero di cui esso √® la radice; questo non implica affatto che nodi a profondit√† maggiore contengano valori minori di quelli a profondit√† minore.

                            Quindi in ogni istante, in un heap decrescente, la radice contiene il valore maggiore.

                            Questa struttura √® molto usata, in particolare, per l'ordinamento di array.

                            Per comprendere meglio il funzionamento dell'algoritmo √® bene capire che gli elementi che si trovano nella seconda met√† dell'array rappresenteranno foglie dello heap e quindi esse saranno gi√† al loro posto giusto; non vi √® infatti alcun elemento dopo di esse.
                        </p>
                    </div>
                    <div id="heapsort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Insertion Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n¬≤)</h4>
                        <p>
                            L‚Äôalgoritmo solitamente ordina la sequenza sul posto. Si assume che la sequenza da ordinare sia partizionata in una sottosequenza gi√† ordinata, all‚Äôinizio composta da un solo elemento, e una ancora da ordinare.
                        </p>
                    </div>
                    <div id="insertionsort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Bubble Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n¬≤)</h4>
                        <p>
                            il Bubble sort o ordinamento a bolla √® un semplice algoritmo di ordinamento di liste di dati. In esso l'insieme di dati viene scansionato, ogni coppia di elementi adiacenti viene comparata ed i due elementi vengono invertiti di posizione se sono nell'ordine sbagliato. L'algoritmo continua nuovamente a ri-eseguire questi passaggi su tutta la lista fino a quando non vengono pi√π eseguiti scambi, situazione che indica che la lista √® ordinata.
                        </p>
                    </div>
                    <div id="bubblesort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Selection Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n¬≤)</h4>
                        <p>
                            L'algoritmo seleziona di volta in volta il numero minore nella sequenza di partenza e lo sposta nella sequenza ordinata; di fatto la sequenza viene suddivisa in due parti: la sottosequenza ordinata, che occupa le prime posizioni dell'array, e la sottosequenza da ordinare, che costituisce la parte restante dell'array.
                        </p>
                    </div>
                    <div id="selectionsort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Cocktail Shaker Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n¬≤)</h4>
                        <p>
                            √® un algoritmo di ordinamento dei dati sviluppato dalla Sun Microsystems. Lo shaker sort √® sostanzialmente una variante del bubble sort: si differenzia da quest'ultimo per l'indice del ciclo pi√π interno che, anzich√© scorrere dall'inizio alla fine, inverte la sua direzione ad ogni ciclo. Pur mantenendo la stessa complessit√†, ovvero O(n¬≤), lo shaker sort riduce la probabilit√† che l'ordinamento abbia un costo corrispondente al caso peggiore.
                        </p>
                    </div>
                    <div id="cocktailsort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Bogo Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n*n!)</h4>
                        <p>
                            Il Bogo sort un algoritmo di ordinamento particolarmente inefficiente. Trasportandolo sull'ordinamento di un mazzo di carte, esso consisterebbe nel mischiare il mazzo a caso per poi controllare se √® ben ordinato e, se non lo √®, ricominciare da capo. Altri nomi con i quali √® conosciuto questo algoritmo sono: stupid sort, blort sort, bort sort, monkey sort, random sort, stochastic sort, goni sort e drunk man sort.
                            Non √® un algoritmo stabile.
                        </p>
                    </div>
                    <div id="bogosort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Binary Search</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(log(n))</h4>
                        <p>
                            L'algoritmo cerca un elemento all'interno di un array che deve necessariamente essere ordinato in ordine crescente, effettuando mediamente meno confronti rispetto ad una ricerca sequenziale, e quindi pi√π rapidamente rispetto ad essa perch√©, sfruttando l'ordinamento, dimezza l'intervallo di ricerca ad ogni passaggio.
                        </p>
                    </div>
                    <div id="binarysearch" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Linear Search</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n)</h4>
                        <p>
                            L'algoritmo controlla in sequenza gli elementi dell'insieme, arrestandosi quando ne trova uno che soddisfa il criterio di ricerca; non potendosi avvalere di alcun ordinamento tra gli elementi, l'algoritmo pu√≤ concludere con certezza che l'insieme non contiene alcun elemento corrispondente solo dopo averli verificati tutti, richiedendo pertanto un numero di controlli, nel caso peggiore, pari alla cardinalit√† dell'intero insieme.
                        </p>
                    </div>
                    <div id="linearsearch" class="sorting"></div>
                </div>
            </div>
        </div>
    </body>
</html>