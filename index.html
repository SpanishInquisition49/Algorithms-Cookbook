<!DOCTYPE html>

<html>
    <head>
        <meta charset="UTF-8">
        <title>Algoritmhs CookBook</title>
        <link rel="stylesheet" href="css/style.css">
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                let elements = [...document.getElementsByClassName("sorting")]
                elements.forEach((element) => {
                    element.innerHTML='<object class="full" type="text/html" data="canvas.html?Sort='+element.id+'" ></object>'
                })
            });
        </script> 
    </head>
    <body>
        <h1>Algoritmhs CookBook</h1>
        <div class="grid">
            <div class="item">
                <h2>Radix Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n+k)</h4>
                        <p>
                            Radix sort utilizza un procedimento controintuitivo per l'uomo, ma pi√π facilmente implementabile. Esegue gli ordinamenti per posizione della cifra ma partendo dalla cifra meno significativa. Questo affinch√© l'algoritmo non si trovi a dovere operare ricorsivamente su sottoproblemi di dimensione non valutabili a priori.
                        </p>
                    </div>
                    <div id="radixsort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Counting Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n)</h4>
                        <p>
                            Il Counting sort √® un algoritmo di ordinamento per valori numerici interi con complessit√† lineare. L'algoritmo si basa sulla conoscenza a priori dell'intervallo in cui sono compresi i valori da ordinare.
                            L'algoritmo conta il numero di occorrenze di ciascun valore presente nell'array da ordinare, memorizzando questa informazione in un array temporaneo di dimensione pari all'intervallo di valori. Il numero di ripetizioni dei valori inferiori indica la posizione del valore immediatamente successivo. 
                        </p>
                    </div>
                    <div id="countingsort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Merge Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† ùöØ(nlog(n))</h4>
                        <p>
                            Il Merge sort √® un algoritmo di tipo divide et impera in cui:
                            <ul>
                                <li><em>Divide</em>: l‚Äôarray A in n subarray, ognuno contente un elemento (l‚Äôarray di un elemento solo √® considerato ordinato)</li>
                                <li><em>Impera</em>: viene fatto il merge di due subarray ordinati ritornando un solo array ordinato di lunghezza A‚Äô.length + A‚Äô‚Äò.length viene ripetuto il merge fino a che non riotteniamo un solo array ordinato.</li>
                            </ul>
                        </p>
                    </div>
                    <div id="mergesort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Quick Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† nel caso pessimo O(n¬≤)</h4>
                        <p>
                            Quicksort is a divide-and-conquer algorithm. It works by selecting a ‚Äòpivot‚Äô element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. For this reason, it is sometimes called partition-exchange sort. The sub-arrays are then sorted recursively. This can be done in-place, requiring small additional amounts of memory to perform the sorting.
                            Quicksort is a comparison sort, meaning that it can sort items of any type for which a ‚Äúless-than‚Äù relation (formally, a total order) is defined. Efficient implementations of Quicksort are not a stable sort, meaning that the relative order of equal sort items is not preserved.
                        </p>
                    </div>
                    <div id="quicksort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Insertion Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n¬≤)</h4>
                        <p>
                            L‚Äôalgoritmo solitamente ordina la sequenza sul posto. Si assume che la sequenza da ordinare sia partizionata in una sottosequenza gi√† ordinata, all‚Äôinizio composta da un solo elemento, e una ancora da ordinare.
                        </p>
                    </div>
                    <div id="insertionsort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Bubble Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n¬≤)</h4>
                        <p>
                            il Bubble sort o ordinamento a bolla √® un semplice algoritmo di ordinamento di liste di dati. In esso l'insieme di dati viene scansionato, ogni coppia di elementi adiacenti viene comparata ed i due elementi vengono invertiti di posizione se sono nell'ordine sbagliato. L'algoritmo continua nuovamente a ri-eseguire questi passaggi su tutta la lista fino a quando non vengono pi√π eseguiti scambi, situazione che indica che la lista √® ordinata.
                        </p>
                    </div>
                    <div id="bubblesort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Selection Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n¬≤)</h4>
                        <p>
                            L'algoritmo seleziona di volta in volta il numero minore nella sequenza di partenza e lo sposta nella sequenza ordinata; di fatto la sequenza viene suddivisa in due parti: la sottosequenza ordinata, che occupa le prime posizioni dell'array, e la sottosequenza da ordinare, che costituisce la parte restante dell'array.
                        </p>
                    </div>
                    <div id="selectionsort" class="sorting"></div>
                </div>
            </div>
            <div class="item">
                <h2>Cocktail Shaker Sort</h2>
                <div class="subGrid">
                    <div>
                        <h4>Complessit√† O(n¬≤)</h4>
                        <p>
                            √® un algoritmo di ordinamento dei dati sviluppato dalla Sun Microsystems. Lo shaker sort √® sostanzialmente una variante del bubble sort: si differenzia da quest'ultimo per l'indice del ciclo pi√π interno che, anzich√© scorrere dall'inizio alla fine, inverte la sua direzione ad ogni ciclo. Pur mantenendo la stessa complessit√†, ovvero O(n¬≤), lo shaker sort riduce la probabilit√† che l'ordinamento abbia un costo corrispondente al caso peggiore.
                        </p>
                    </div>
                    <div id="cocktailsort" class="sorting"></div>
                </div>
            </div>
        </div>
    </body>
</html>